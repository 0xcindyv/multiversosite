<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Teste do Player de Vídeo Exclusivo com Three.js</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            font-family: Arial, sans-serif;
            color: white;
        }

        #container {
            position: relative;
            width: 100%;
            height: 100vh;
        }

        canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }

        #css-renderer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 2;
        }

        .video-container {
            width: 900px;
            height: 500px;
            background-color: #000000;
            border: 20px solid #FF00FF;
            border-radius: 15px;
            overflow: hidden;
            box-shadow: 0 0 50px #FF00FF, 0 0 100px #FF00FF;
            position: absolute;
            left: -9999px; /* Escondido inicialmente */
        }

        .video-title {
            background-color: #FF00FF;
            color: white;
            padding: 15px;
            font-size: 24px;
            font-weight: bold;
            text-align: center;
            text-shadow: 0 0 10px white;
            animation: pulse 1s infinite;
        }

        @keyframes pulse {
            0% { opacity: 0.7; }
            50% { opacity: 1; }
            100% { opacity: 0.7; }
        }

        iframe {
            width: 100%;
            height: calc(100% - 54px);
            border: none;
            background-color: #000;
        }

        /* Vídeo HTML5 */
        video {
            width: 100%;
            height: calc(100% - 54px);
            object-fit: cover;
            background-color: #000;
        }

        /* Fallback para caso o CSS3D não funcione */
        #fallback-container {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            display: none;
            z-index: 100;
        }

        #error-message {
            position: fixed;
            top: 10px;
            left: 10px;
            background-color: rgba(0, 0, 0, 0.7);
            color: #ff0000;
            padding: 10px;
            border-radius: 5px;
            font-size: 14px;
            z-index: 1000;
            display: none;
        }
        
        /* Formulário para token de autenticação */
        #auth-form {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.8);
            padding: 20px;
            border-radius: 10px;
            border: 2px solid #FF00FF;
            z-index: 1000;
            width: 400px;
            max-width: 90%;
        }
        
        #auth-form input {
            width: 100%;
            padding: 10px;
            margin: 10px 0;
            border-radius: 5px;
            border: 1px solid #FF00FF;
            background-color: #222;
            color: white;
        }
        
        #auth-form button {
            background-color: #FF00FF;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            margin-top: 10px;
        }
        
        #auth-form button:hover {
            background-color: #cc00cc;
        }
        
        /* Debug panel */
        #debug-panel {
            position: fixed;
            bottom: 10px;
            left: 10px;
            background-color: rgba(0, 0, 0, 0.7);
            color: #00ff00;
            padding: 10px;
            border-radius: 5px;
            font-size: 12px;
            font-family: monospace;
            z-index: 1000;
            max-width: 80%;
            max-height: 200px;
            overflow: auto;
        }

        /* Aviso de domínio */
        .domain-warning {
            margin-top: 15px;
            padding: 10px;
            background-color: rgba(255, 255, 0, 0.2);
            border-radius: 5px;
            font-size: 12px;
            color: #ffcc00;
            border: 1px solid #ffcc00;
        }

        /* Versão do player */
        .version-info {
            position: fixed;
            bottom: 10px;
            right: 10px;
            background-color: rgba(0, 0, 0, 0.7);
            color: #FF00FF;
            padding: 5px 10px;
            border-radius: 5px;
            font-size: 10px;
            z-index: 1000;
        }
    </style>
</head>
<body>
    <div id="container">
        <div id="css-renderer"></div>
    </div>

    <!-- Formulário para inserir a chave de autenticação -->
    <div id="auth-form">
        <h2>Autenticação Bunny Stream</h2>
        <p>Insira sua chave de segurança do Bunny Stream para acessar o vídeo:</p>
        <input type="text" id="security-key" placeholder="Token Authentication Key">
        <p><small>Use a chave "Token Authentication Key" do painel do Bunny Stream</small></p>
        <button id="auth-submit">Acessar Vídeo</button>
        <div>
            <label>
                <input type="checkbox" id="debug-mode"> Modo de depuração
            </label>
        </div>
        <div class="domain-warning">
            <strong>Nota:</strong> O Bunny Stream só permite acesso a partir dos domínios autorizados (multiverso.club e 0xcindyv.github.io/multiverso/). 
            Este player não funcionará localmente com o protocolo file://.
        </div>
        <div style="margin-top: 15px; padding: 10px; background-color: rgba(0, 255, 0, 0.1); border-radius: 5px; font-size: 12px; color: #00cc00; border: 1px solid #00cc00;">
            <strong>Teste GitHub Pages:</strong> Esta versão está sendo testada no GitHub Pages para verificar a autenticação do Bunny Stream em um domínio autorizado.
        </div>
    </div>

    <div id="video-front" class="video-container">
        <div class="video-title">✨ CONTEÚDO EXCLUSIVO PARA HODLERS ✨</div>
        <!-- O iframe será inserido via JavaScript com o token -->
        <div id="front-player-container"></div>
    </div>

    <div id="video-back" class="video-container">
        <div class="video-title">✨ CONTEÚDO EXCLUSIVO PARA HODLERS ✨</div>
        <!-- O iframe será inserido via JavaScript com o token -->
        <div id="back-player-container"></div>
    </div>

    <div id="fallback-container"></div>
    <div id="error-message"></div>
    <div id="debug-panel" style="display: none;"></div>
    <div class="version-info">Versão: 1.1 - Atualizado em: 03/03/2024</div>

    <!-- Importar Three.js diretamente - versão mais antiga e estável -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/110/three.min.js"></script>
    <!-- Importar biblioteca para gerar hash SHA256 -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/js-sha256/0.9.0/sha256.min.js"></script>

    <script>
        // Configurações do vídeo
        const VIDEO_ID = 'c4729b0e-0865-48ee-8520-728aae9d970a';
        const LIBRARY_ID = '203779';
        let debugMode = false;
        
        // Função para adicionar mensagens de depuração
        function debug(message, data) {
            if (!debugMode) return;
            
            const debugPanel = document.getElementById('debug-panel');
            const timestamp = new Date().toLocaleTimeString();
            let debugMessage = `<div>[${timestamp}] ${message}</div>`;
            
            if (data) {
                if (typeof data === 'object') {
                    debugMessage += `<pre>${JSON.stringify(data, null, 2)}</pre>`;
                } else {
                    debugMessage += `<pre>${data}</pre>`;
                }
            }
            
            debugPanel.innerHTML += debugMessage;
            debugPanel.scrollTop = debugPanel.scrollHeight;
            console.log(`[DEBUG] ${message}`, data);
        }

        // Definição do CSS3DObject
        function CSS3DObject(element) {
            THREE.Object3D.call(this);
            this.element = element;
            this.element.style.position = 'absolute';
            this.element.style.pointerEvents = 'auto';
        }

        CSS3DObject.prototype = Object.create(THREE.Object3D.prototype);
        CSS3DObject.prototype.constructor = CSS3DObject;

        // Definição do CSS3DRenderer
        function CSS3DRenderer() {
            const matrix = new THREE.Matrix4();
            const domElement = document.createElement('div');
            domElement.style.overflow = 'hidden';
            this.domElement = domElement;

            const cameraElement = document.createElement('div');
            cameraElement.style.transformStyle = 'preserve-3d';
            cameraElement.style.pointerEvents = 'none';
            domElement.appendChild(cameraElement);

            this.getSize = function () {
                return {
                    width: window.innerWidth,
                    height: window.innerHeight
                };
            };

            this.setSize = function (width, height) {
                domElement.style.width = width + 'px';
                domElement.style.height = height + 'px';
            };

            const renderObject = function (object, scene, camera) {
                if (object instanceof CSS3DObject) {
                    const element = object.element;

                    matrix.copy(camera.matrixWorldInverse);
                    matrix.multiply(object.matrixWorld);

                    const style = 'translate(-50%,-50%) matrix3d(' +
                        matrix.elements.join(',') +
                        ')';

                    element.style.WebkitTransform = style;
                    element.style.MozTransform = style;
                    element.style.transform = style;

                    element.style.display = '';

                    if (element.parentNode !== cameraElement) {
                        cameraElement.appendChild(element);
                    }
                }

                for (let i = 0, l = object.children.length; i < l; i++) {
                    renderObject(object.children[i], scene, camera);
                }
            };

            this.render = function (scene, camera) {
                scene.updateMatrixWorld();

                if (camera.parent === null) camera.updateMatrixWorld();

                cameraElement.style.transform = 'translateZ(' + (camera.position.z * -1) + 'px)';

                renderObject(scene, scene, camera);
            };
        }

        // Implementação simplificada do OrbitControls
        function OrbitControls(camera, domElement) {
            this.camera = camera;
            this.domElement = domElement;
            this.target = new THREE.Vector3();
            this.enableDamping = false;
            this.dampingFactor = 0.05;
            
            // Variáveis para controle do mouse
            let isMouseDown = false;
            let mouseX = 0, mouseY = 0;
            let targetRotationX = 0, targetRotationY = 0;
            let currentRotationX = 0, currentRotationY = 0;
            
            // Eventos do mouse
            domElement.addEventListener('mousedown', onMouseDown, false);
            domElement.addEventListener('mousemove', onMouseMove, false);
            domElement.addEventListener('mouseup', onMouseUp, false);
            
            function onMouseDown(event) {
                isMouseDown = true;
                mouseX = event.clientX;
                mouseY = event.clientY;
            }
            
            function onMouseMove(event) {
                if (isMouseDown) {
                    const deltaX = event.clientX - mouseX;
                    const deltaY = event.clientY - mouseY;
                    
                    targetRotationY += deltaX * 0.01;
                    targetRotationX += deltaY * 0.01;
                    
                    mouseX = event.clientX;
                    mouseY = event.clientY;
                }
            }
            
            function onMouseUp() {
                isMouseDown = false;
            }
            
            // Método de atualização
            this.update = function() {
                if (this.enableDamping) {
                    currentRotationX += (targetRotationX - currentRotationX) * this.dampingFactor;
                    currentRotationY += (targetRotationY - currentRotationY) * this.dampingFactor;
                } else {
                    currentRotationX = targetRotationX;
                    currentRotationY = targetRotationY;
                }
                
                // Limitar rotação vertical
                currentRotationX = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, currentRotationX));
                
                // Aplicar rotação à câmera
                camera.position.x = 3000 * Math.sin(currentRotationY) * Math.cos(currentRotationX);
                camera.position.y = 3000 * Math.sin(currentRotationX);
                camera.position.z = 3000 * Math.cos(currentRotationY) * Math.cos(currentRotationX);
                
                camera.lookAt(this.target);
            };
        }

        // Mostrar mensagem de erro
        function showError(message) {
            const errorElement = document.getElementById('error-message');
            errorElement.textContent = message;
            errorElement.style.display = 'block';
            console.error(message);
        }

        // Mostrar fallback
        function showFallback() {
            const fallbackContainer = document.getElementById('fallback-container');
            fallbackContainer.style.display = 'block';
            fallbackContainer.innerHTML = '';
            
            const videoClone = document.getElementById('video-front').cloneNode(true);
            videoClone.style.position = 'static';
            videoClone.style.left = '0';
            
            fallbackContainer.appendChild(videoClone);
        }
        
        // Gerar token de autenticação para Bunny Stream
        function generateBunnyToken(securityKey, videoId, expirationTimeInSeconds = 3600) {
            // Calcular timestamp de expiração
            const expirationTimestamp = Math.floor(Date.now() / 1000) + expirationTimeInSeconds;
            
            debug('Gerando token com:', {
                securityKey: securityKey.substring(0, 3) + '...',
                videoId,
                expirationTimestamp
            });
            
            // Gerar token SHA256
            const tokenContent = securityKey + videoId + expirationTimestamp;
            const token = sha256(tokenContent);
            
            debug('Token gerado:', token);
            
            return {
                token: token,
                expires: expirationTimestamp
            };
        }
        
        // Criar URL segura para o iframe do Bunny Stream
        function createSecureEmbedUrl(securityKey, videoId, libraryId) {
            const auth = generateBunnyToken(securityKey, videoId);
            const url = `https://iframe.mediadelivery.net/embed/${libraryId}/${videoId}?token=${auth.token}&expires=${auth.expires}&autoplay=true&preload=true`;
            
            debug('URL segura criada:', url);
            
            return url;
        }
        
        // Criar iframe com autenticação
        function createAuthenticatedIframe(url) {
            debug('Criando iframe com URL:', url);
            
            const iframe = document.createElement('iframe');
            iframe.src = url;
            iframe.allow = "accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture";
            iframe.allowFullscreen = true;
            iframe.loading = "eager";
            iframe.title = "Conteúdo Exclusivo";
            
            // Adicionar eventos para depuração
            iframe.onerror = function() {
                debug('Erro ao carregar iframe');
            };
            
            iframe.onload = function() {
                debug('Iframe carregado com sucesso');
            };
            
            return iframe;
        }
        
        // Inicializar player com autenticação
        function initializeAuthenticatedPlayer(securityKey) {
            try {
                debug('Inicializando player com chave de segurança');
                
                // Gerar URLs seguras
                const secureUrl = createSecureEmbedUrl(securityKey, VIDEO_ID, LIBRARY_ID);
                
                // Criar iframes
                const frontIframe = createAuthenticatedIframe(secureUrl);
                const backIframe = createAuthenticatedIframe(secureUrl);
                
                // Adicionar iframes aos containers
                document.getElementById('front-player-container').innerHTML = '';
                document.getElementById('back-player-container').innerHTML = '';
                document.getElementById('front-player-container').appendChild(frontIframe);
                document.getElementById('back-player-container').appendChild(backIframe);
                
                // Esconder formulário de autenticação
                document.getElementById('auth-form').style.display = 'none';
                
                // Inicializar Three.js
                debug('Iniciando Three.js');
                initializeThreeJs();
                
                return true;
            } catch (error) {
                debug('Erro ao inicializar player:', error.message);
                showError('Erro ao inicializar player autenticado: ' + error.message);
                return false;
            }
        }
        
        // Verificar se o iframe do Bunny carregou corretamente
        function checkBunnyIframe() {
            const iframes = document.querySelectorAll('iframe');
            let allLoaded = true;
            
            debug(`Verificando ${iframes.length} iframes`);
            
            iframes.forEach((iframe, index) => {
                iframe.onerror = function() {
                    debug(`Erro ao carregar o iframe ${index}`);
                    showFallbackVideo(iframe);
                };
                
                // Adicionar evento de load para verificar se carregou com sucesso
                iframe.onload = function() {
                    debug(`Iframe ${index} carregado com sucesso`);
                };
                
                // Tentar detectar erro 404 ou outros problemas
                setTimeout(() => {
                    try {
                        debug(`Verificando conteúdo do iframe ${index}`);
                        
                        // Verificar se o iframe tem conteúdo
                        if (iframe.contentWindow.document.body.innerHTML === '') {
                            debug(`Iframe ${index} parece vazio, usando fallback`);
                            showFallbackVideo(iframe);
                        }
                    } catch (e) {
                        // Erro de segurança cross-origin é esperado
                        debug(`Não foi possível acessar o conteúdo do iframe ${index} (normal devido a restrições de segurança)`, e.message);
                        
                        // Verificar se o iframe está com erro 404 (verificando altura)
                        if (iframe.clientHeight < 50) {
                            debug(`Iframe ${index} parece ter erro 404 (altura muito pequena), usando fallback`);
                            showFallbackVideo(iframe);
                        }
                    }
                }, 3000);
            });
            
            return allLoaded;
        }
        
        // Substituir iframe por vídeo de fallback
        function showFallbackVideo(iframe) {
            // Tentar primeiro com um player HTML5 direto do Bunny Stream
            try {
                const video = document.createElement('video');
                video.controls = true;
                video.autoplay = true;
                video.loop = true;
                video.muted = false;
                // Tentar URL direta do Bunny Stream (se disponível)
                video.src = 'https://vz-c4729b0e-0865-48ee-8520-728aae9d970a.b-cdn.net/c4729b0e-0865-48ee-8520-728aae9d970a.mp4';
                video.style.width = '100%';
                video.style.height = 'calc(100% - 54px)';
                video.onerror = function() {
                    // Se falhar, usar o vídeo de fallback
                    video.src = 'https://commondatastorage.googleapis.com/gtv-videos-bucket/sample/BigBuckBunny.mp4';
                };
                
                iframe.parentNode.replaceChild(video, iframe);
            } catch (e) {
                console.error('Erro ao criar vídeo de fallback:', e);
                // Usar o vídeo de fallback padrão
                const video = document.createElement('video');
                video.controls = true;
                video.autoplay = true;
                video.loop = true;
                video.src = 'https://commondatastorage.googleapis.com/gtv-videos-bucket/sample/BigBuckBunny.mp4';
                video.style.width = '100%';
                video.style.height = 'calc(100% - 54px)';
                
                iframe.parentNode.replaceChild(video, iframe);
            }
        }

        // Inicializar Three.js
        function initializeThreeJs() {
            try {
                // Verificar se Three.js está disponível
                if (typeof THREE === 'undefined') {
                    throw new Error('Three.js não foi carregado corretamente');
                }

                // Verificar se os iframes do Bunny carregaram
                checkBunnyIframe();

                // Configuração da cena, câmera e renderizadores
                const scene = new THREE.Scene();
                const cssScene = new THREE.Scene();
                
                const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 20000);
                camera.position.set(0, 0, 3000);
                
                // Renderizador WebGL para objetos 3D
                const renderer = new THREE.WebGLRenderer({ antialias: true });
                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.setClearColor(0x000000);
                document.getElementById('container').appendChild(renderer.domElement);
                
                // Renderizador CSS3D para elementos HTML
                const cssRenderer = new CSS3DRenderer();
                cssRenderer.setSize(window.innerWidth, window.innerHeight);
                cssRenderer.domElement.id = 'css-renderer';
                document.getElementById('container').appendChild(cssRenderer.domElement);
                
                // Adicionar controles de órbita para navegação
                const controls = new OrbitControls(camera, renderer.domElement);
                controls.enableDamping = true;
                controls.dampingFactor = 0.05;
                
                // Criar player de vídeo exclusivo
                function createExclusiveVideoPlayer() {
                    console.log('Criando player de vídeo exclusivo');
                    
                    // Obter elementos DOM
                    const videoElement = document.getElementById('video-front');
                    const videoElementBack = document.getElementById('video-back');
                    
                    // Tornar os elementos visíveis
                    videoElement.style.left = '0';
                    videoElementBack.style.left = '0';
                    
                    // Criar grupo para conter os dois lados do player
                    const videoGroup = new THREE.Group();
                    videoGroup.name = 'exclusive-video-group';
                    
                    // Criar objeto CSS3D para frente
                    const videoObject = new CSS3DObject(videoElement);
                    videoObject.position.set(0, 0, 0);
                    videoObject.scale.set(1, 1, 1);
                    
                    // Criar objeto CSS3D para verso
                    const videoObjectBack = new CSS3DObject(videoElementBack);
                    videoObjectBack.position.set(0, 0, -1); // 1 unidade atrás para evitar z-fighting
                    videoObjectBack.scale.set(1, 1, 1);
                    videoObjectBack.rotation.y = Math.PI; // Rotacionar 180 graus
                    
                    // Adicionar objetos ao grupo
                    videoGroup.add(videoObject);
                    videoGroup.add(videoObjectBack);
                    
                    // Adicionar grupo à cena CSS3D
                    cssScene.add(videoGroup);
                    
                    console.log('Player de vídeo exclusivo criado com sucesso');
                    
                    // Adicionar marcador visual (esfera)
                    const markerGeometry = new THREE.SphereGeometry(100, 32, 32);
                    const markerMaterial = new THREE.MeshBasicMaterial({
                        color: 0xFF00FF,
                        transparent: true,
                        opacity: 0.9
                    });
                    
                    const marker = new THREE.Mesh(markerGeometry, markerMaterial);
                    marker.position.set(0, 300, 0);
                    marker.name = 'exclusive-video-marker';
                    scene.add(marker);
                    
                    // Adicionar luz para iluminar o player
                    const spotLight = new THREE.SpotLight(0xFF00FF, 2);
                    spotLight.position.set(0, 500, 500);
                    spotLight.target.position.set(0, 0, 0);
                    scene.add(spotLight);
                    scene.add(spotLight.target);
                    
                    // Animar o marcador
                    function animateMarker() {
                        requestAnimationFrame(animateMarker);
                        
                        const time = Date.now() * 0.001;
                        marker.position.y = 300 + Math.sin(time) * 50;
                        marker.scale.setScalar(1 + Math.sin(time * 0.5) * 0.2);
                    }
                    
                    animateMarker();
                    
                    return {
                        videoGroup,
                        marker,
                        spotLight
                    };
                }
                
                // Criar player de vídeo exclusivo
                const exclusiveVideoPlayer = createExclusiveVideoPlayer();
                
                // Adicionar plano para referência
                const planeGeometry = new THREE.PlaneGeometry(2000, 2000);
                const planeMaterial = new THREE.MeshBasicMaterial({
                    color: 0x333333,
                    side: THREE.DoubleSide,
                    wireframe: true
                });
                
                const plane = new THREE.Mesh(planeGeometry, planeMaterial);
                plane.position.set(0, 0, -500);
                scene.add(plane);
                
                // Função de animação
                function animate() {
                    requestAnimationFrame(animate);
                    
                    // Atualizar controles
                    controls.update();
                    
                    // Renderizar cenas
                    renderer.render(scene, camera);
                    cssRenderer.render(cssScene, camera);
                }
                
                // Iniciar animação
                animate();
                
                // Ajustar tamanho da janela
                window.addEventListener('resize', () => {
                    camera.aspect = window.innerWidth / window.innerHeight;
                    camera.updateProjectionMatrix();
                    
                    renderer.setSize(window.innerWidth, window.innerHeight);
                    cssRenderer.setSize(window.innerWidth, window.innerHeight);
                });
            } catch (error) {
                showError('Erro ao inicializar Three.js: ' + error.message);
                showFallback();
            }
        }
        
        // Adicionar evento ao botão de autenticação
        document.getElementById('auth-submit').addEventListener('click', function() {
            const securityKey = document.getElementById('security-key').value.trim();
            debugMode = document.getElementById('debug-mode').checked;
            
            // Mostrar ou esconder painel de depuração
            document.getElementById('debug-panel').style.display = debugMode ? 'block' : 'none';
            
            if (!securityKey) {
                showError('Por favor, insira uma chave de segurança válida');
                return;
            }
            
            debug('Chave de segurança fornecida:', securityKey.substring(0, 3) + '...');
            
            // Inicializar player com a chave fornecida
            if (initializeAuthenticatedPlayer(securityKey)) {
                debug('Player inicializado com sucesso');
            } else {
                debug('Falha ao inicializar o player');
                showError('Falha ao inicializar o player. Verifique a chave de segurança.');
            }
        });
        
        // Adicionar opção para testar com vídeo de fallback diretamente
        document.addEventListener('DOMContentLoaded', function() {
            // Adicionar botão para usar vídeo de fallback diretamente
            const authForm = document.getElementById('auth-form');
            const fallbackButton = document.createElement('button');
            fallbackButton.textContent = 'Usar Vídeo de Teste';
            fallbackButton.style.backgroundColor = '#555';
            fallbackButton.style.marginLeft = '10px';
            
            fallbackButton.addEventListener('click', function() {
                // Criar elementos de vídeo diretamente
                const frontVideo = document.createElement('video');
                frontVideo.src = 'https://commondatastorage.googleapis.com/gtv-videos-bucket/sample/BigBuckBunny.mp4';
                frontVideo.controls = true;
                frontVideo.autoplay = true;
                frontVideo.loop = true;
                frontVideo.style.width = '100%';
                frontVideo.style.height = 'calc(100% - 54px)';
                
                const backVideo = frontVideo.cloneNode(true);
                
                // Adicionar vídeos aos containers
                document.getElementById('front-player-container').innerHTML = '';
                document.getElementById('back-player-container').innerHTML = '';
                document.getElementById('front-player-container').appendChild(frontVideo);
                document.getElementById('back-player-container').appendChild(backVideo);
                
                // Esconder formulário de autenticação
                document.getElementById('auth-form').style.display = 'none';
                
                // Inicializar Three.js
                initializeThreeJs();
            });
            
            // Adicionar botão ao formulário
            const buttonContainer = document.createElement('div');
            buttonContainer.style.marginTop = '10px';
            buttonContainer.appendChild(fallbackButton);
            authForm.appendChild(buttonContainer);
        });
    </script>
</body>
</html> 